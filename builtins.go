// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package colony

import (
	"sync"
	"unsafe"
)

type Complex64Colony struct {
	entry *colonyGroupcomplex64
}

// NewComplex64Colony returns a new colony of complex64's.
func NewComplex64Colony(size uint) *Complex64Colony {
	return &Complex64Colony{
		entry: newcomplex64Group(nil, size),
	}
}

//// Iterate sends pointers to all instances of complex64 in the colony to the given channel.
//func (c *Complex64Colony) Iterate() <-chan *complex64 {
// ch := make(chan *complex64)
//	var wg sync.WaitGroup
//	for g := c.entry; g != nil; g = g.next {
//		wg.Add(1)
// go func(g *colonyGroupcomplex64) {
//			g.l.RLock()
//			//for i, e := g.index.NextSet(0); e; i, e = g.index.NextSet(i + 1) {
//			//	ch <- &g.data[i]
//			//}
//			for _, f := range g.free {
//
//			}
//			g.l.RUnlock()
//			wg.Done()
//		}(g)
//	}
//	go func() {
//		wg.Wait()
//		close(ch)
//	}()
//	return ch
//}

func (c *Complex64Colony) Insert(t *complex64) (tp *complex64) {
	return c.entry.Insert(t)
}

func (c *Complex64Colony) Delete(tp *complex64) {
	c.entry.Delete(tp)
}

func newcomplex64Group(previous *colonyGroupcomplex64, size uint) *colonyGroupcomplex64 {
	var g colonyGroupcomplex64
	if size == 0 {
		size = 8
	}
	g.data = make([]complex64, size)
	g.free = make(chan *complex64, size)
	for i := 0; i < len(g.data); i++ {
		g.free <- &g.data[i]
	}
	g.next = nil
	g.l = &sync.RWMutex{}
	g.previous = previous
	g.minPtr = uintptr(unsafe.Pointer(&g.data[0]))
	g.maxPtr = uintptr(unsafe.Pointer(&g.data[len(g.data)-1]))
	return &g
}

type colonyGroupcomplex64 struct {
	data     []complex64
	free     chan *complex64
	maxPtr   uintptr
	minPtr   uintptr
	next     *colonyGroupcomplex64
	previous *colonyGroupcomplex64

	l *sync.RWMutex
}

func (g *colonyGroupcomplex64) Insert(t *complex64) (tp *complex64) {
	select {
	case tp = <-g.free:
		return
	default:
		if g.next == nil {
			g.next = newcomplex64Group(g, uint(len(g.data)*2))
		}
		return g.next.Insert(t)
	}
	//if i, e := g.index.NextClear(0); e {
	//	g.data[i] = *t
	//	g.index.Set(i)
	//	tp = &g.data[i]
	//	g.l.Unlock()
	//	return
	//}
}

func (g *colonyGroupcomplex64) Delete(tp *complex64) {
	tpu := uintptr(unsafe.Pointer(tp))
	if tpu < g.minPtr || tpu > g.maxPtr { // hack to determine if a pointer points to this array
		g.next.Delete(tp)
	}
	g.free <- tp
	//if !g.index.Any() {
	// TODO: if a group has no more elements, then we should de-allocate it.
	//}
	return
}
