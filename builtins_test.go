// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package colony

import "testing"

func TestBoolColony(t *testing.T) {
	colony := NewBoolColony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(bool)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(bool)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var BoolBenchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkBoolColony_Insert(b *testing.B) {
	for _, bm := range BoolBenchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewBoolColony()
				newbool := new(bool)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newbool = colony.Insert(newbool)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkBoolSlice(b *testing.B) {
	for _, bm := range BoolBenchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []bool
				newbool := new(bool)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newbool)
					}
				}
			}
		}(bm.count))
	}
}

func TestByteColony(t *testing.T) {
	colony := NewByteColony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(byte)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(byte)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var ByteBenchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkByteColony_Insert(b *testing.B) {
	for _, bm := range ByteBenchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewByteColony()
				newbyte := new(byte)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newbyte = colony.Insert(newbyte)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkByteSlice(b *testing.B) {
	for _, bm := range ByteBenchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []byte
				newbyte := new(byte)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newbyte)
					}
				}
			}
		}(bm.count))
	}
}

func TestComplex128Colony(t *testing.T) {
	colony := NewComplex128Colony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(complex128)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(complex128)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var Complex128Benchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkComplex128Colony_Insert(b *testing.B) {
	for _, bm := range Complex128Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewComplex128Colony()
				newcomplex128 := new(complex128)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newcomplex128 = colony.Insert(newcomplex128)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkComplex128Slice(b *testing.B) {
	for _, bm := range Complex128Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []complex128
				newcomplex128 := new(complex128)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newcomplex128)
					}
				}
			}
		}(bm.count))
	}
}

func TestComplex64Colony(t *testing.T) {
	colony := NewComplex64Colony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(complex64)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(complex64)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var Complex64Benchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkComplex64Colony_Insert(b *testing.B) {
	for _, bm := range Complex64Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewComplex64Colony()
				newcomplex64 := new(complex64)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newcomplex64 = colony.Insert(newcomplex64)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkComplex64Slice(b *testing.B) {
	for _, bm := range Complex64Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []complex64
				newcomplex64 := new(complex64)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newcomplex64)
					}
				}
			}
		}(bm.count))
	}
}

func TestErrorColony(t *testing.T) {
	colony := NewErrorColony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(error)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(error)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var ErrorBenchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkErrorColony_Insert(b *testing.B) {
	for _, bm := range ErrorBenchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewErrorColony()
				newerror := new(error)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newerror = colony.Insert(newerror)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkErrorSlice(b *testing.B) {
	for _, bm := range ErrorBenchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []error
				newerror := new(error)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newerror)
					}
				}
			}
		}(bm.count))
	}
}

func TestFloat32Colony(t *testing.T) {
	colony := NewFloat32Colony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(float32)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(float32)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var Float32Benchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkFloat32Colony_Insert(b *testing.B) {
	for _, bm := range Float32Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewFloat32Colony()
				newfloat32 := new(float32)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newfloat32 = colony.Insert(newfloat32)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkFloat32Slice(b *testing.B) {
	for _, bm := range Float32Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []float32
				newfloat32 := new(float32)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newfloat32)
					}
				}
			}
		}(bm.count))
	}
}

func TestFloat64Colony(t *testing.T) {
	colony := NewFloat64Colony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(float64)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(float64)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var Float64Benchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkFloat64Colony_Insert(b *testing.B) {
	for _, bm := range Float64Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewFloat64Colony()
				newfloat64 := new(float64)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newfloat64 = colony.Insert(newfloat64)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkFloat64Slice(b *testing.B) {
	for _, bm := range Float64Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []float64
				newfloat64 := new(float64)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newfloat64)
					}
				}
			}
		}(bm.count))
	}
}

func TestIntColony(t *testing.T) {
	colony := NewIntColony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(int)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(int)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var IntBenchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkIntColony_Insert(b *testing.B) {
	for _, bm := range IntBenchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewIntColony()
				newint := new(int)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newint = colony.Insert(newint)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkIntSlice(b *testing.B) {
	for _, bm := range IntBenchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []int
				newint := new(int)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newint)
					}
				}
			}
		}(bm.count))
	}
}

func TestInt16Colony(t *testing.T) {
	colony := NewInt16Colony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(int16)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(int16)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var Int16Benchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkInt16Colony_Insert(b *testing.B) {
	for _, bm := range Int16Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewInt16Colony()
				newint16 := new(int16)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newint16 = colony.Insert(newint16)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkInt16Slice(b *testing.B) {
	for _, bm := range Int16Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []int16
				newint16 := new(int16)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newint16)
					}
				}
			}
		}(bm.count))
	}
}

func TestInt32Colony(t *testing.T) {
	colony := NewInt32Colony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(int32)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(int32)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var Int32Benchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkInt32Colony_Insert(b *testing.B) {
	for _, bm := range Int32Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewInt32Colony()
				newint32 := new(int32)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newint32 = colony.Insert(newint32)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkInt32Slice(b *testing.B) {
	for _, bm := range Int32Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []int32
				newint32 := new(int32)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newint32)
					}
				}
			}
		}(bm.count))
	}
}

func TestInt64Colony(t *testing.T) {
	colony := NewInt64Colony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(int64)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(int64)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var Int64Benchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkInt64Colony_Insert(b *testing.B) {
	for _, bm := range Int64Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewInt64Colony()
				newint64 := new(int64)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newint64 = colony.Insert(newint64)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkInt64Slice(b *testing.B) {
	for _, bm := range Int64Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []int64
				newint64 := new(int64)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newint64)
					}
				}
			}
		}(bm.count))
	}
}

func TestInt8Colony(t *testing.T) {
	colony := NewInt8Colony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(int8)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(int8)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var Int8Benchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkInt8Colony_Insert(b *testing.B) {
	for _, bm := range Int8Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewInt8Colony()
				newint8 := new(int8)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newint8 = colony.Insert(newint8)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkInt8Slice(b *testing.B) {
	for _, bm := range Int8Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []int8
				newint8 := new(int8)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newint8)
					}
				}
			}
		}(bm.count))
	}
}

func TestRuneColony(t *testing.T) {
	colony := NewRuneColony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(rune)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(rune)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var RuneBenchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkRuneColony_Insert(b *testing.B) {
	for _, bm := range RuneBenchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewRuneColony()
				newrune := new(rune)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newrune = colony.Insert(newrune)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkRuneSlice(b *testing.B) {
	for _, bm := range RuneBenchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []rune
				newrune := new(rune)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newrune)
					}
				}
			}
		}(bm.count))
	}
}

func TestStringColony(t *testing.T) {
	colony := NewStringColony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(string)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(string)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var StringBenchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkStringColony_Insert(b *testing.B) {
	for _, bm := range StringBenchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewStringColony()
				newstring := new(string)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newstring = colony.Insert(newstring)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkStringSlice(b *testing.B) {
	for _, bm := range StringBenchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []string
				newstring := new(string)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newstring)
					}
				}
			}
		}(bm.count))
	}
}

func TestUintColony(t *testing.T) {
	colony := NewUintColony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(uint)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(uint)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var UintBenchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkUintColony_Insert(b *testing.B) {
	for _, bm := range UintBenchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewUintColony()
				newuint := new(uint)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newuint = colony.Insert(newuint)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkUintSlice(b *testing.B) {
	for _, bm := range UintBenchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []uint
				newuint := new(uint)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newuint)
					}
				}
			}
		}(bm.count))
	}
}

func TestUint16Colony(t *testing.T) {
	colony := NewUint16Colony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(uint16)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(uint16)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var Uint16Benchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkUint16Colony_Insert(b *testing.B) {
	for _, bm := range Uint16Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewUint16Colony()
				newuint16 := new(uint16)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newuint16 = colony.Insert(newuint16)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkUint16Slice(b *testing.B) {
	for _, bm := range Uint16Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []uint16
				newuint16 := new(uint16)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newuint16)
					}
				}
			}
		}(bm.count))
	}
}

func TestUint32Colony(t *testing.T) {
	colony := NewUint32Colony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(uint32)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(uint32)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var Uint32Benchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkUint32Colony_Insert(b *testing.B) {
	for _, bm := range Uint32Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewUint32Colony()
				newuint32 := new(uint32)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newuint32 = colony.Insert(newuint32)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkUint32Slice(b *testing.B) {
	for _, bm := range Uint32Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []uint32
				newuint32 := new(uint32)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newuint32)
					}
				}
			}
		}(bm.count))
	}
}

func TestUint64Colony(t *testing.T) {
	colony := NewUint64Colony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(uint64)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(uint64)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var Uint64Benchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkUint64Colony_Insert(b *testing.B) {
	for _, bm := range Uint64Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewUint64Colony()
				newuint64 := new(uint64)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newuint64 = colony.Insert(newuint64)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkUint64Slice(b *testing.B) {
	for _, bm := range Uint64Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []uint64
				newuint64 := new(uint64)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newuint64)
					}
				}
			}
		}(bm.count))
	}
}

func TestUint8Colony(t *testing.T) {
	colony := NewUint8Colony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(uint8)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(uint8)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var Uint8Benchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkUint8Colony_Insert(b *testing.B) {
	for _, bm := range Uint8Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewUint8Colony()
				newuint8 := new(uint8)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newuint8 = colony.Insert(newuint8)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkUint8Slice(b *testing.B) {
	for _, bm := range Uint8Benchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []uint8
				newuint8 := new(uint8)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newuint8)
					}
				}
			}
		}(bm.count))
	}
}

func TestUintptrColony(t *testing.T) {
	colony := NewUintptrColony()
	t.Run("Insert", func(t *testing.T) {
		newT := new(uintptr)
		tp := colony.Insert(newT)
		if *tp != *newT {
			t.Fatalf("value of pointer returned from Insert does not equal the inserted value: (*newT) %v != (*tp) %v", *newT, *tp)
		}
	})
	t.Run("Delete", func(t *testing.T) {
		newT := new(uintptr)
		tp := colony.Insert(newT)
		colony.Delete(tp)
		tp2 := colony.Insert(newT)
		if tp != tp2 { // both should be allocated to the same spot
			t.Fatalf("deletion failed")
		}
	})
}

var UintptrBenchmarks = []struct {
	name  string
	count int
}{
	{"1", 1},
	{"10", 10},
	{"100", 100},
	{"1000", 1000},
	{"10000", 10000},
	{"100000", 100000},
	{"1000000", 1000000},
}

func BenchmarkUintptrColony_Insert(b *testing.B) {
	for _, bm := range UintptrBenchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				colony := NewUintptrColony()
				newuintptr := new(uintptr)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						newuintptr = colony.Insert(newuintptr)
					}
				}
			}
		}(bm.count))
	}
}

func BenchmarkUintptrSlice(b *testing.B) {
	for _, bm := range UintptrBenchmarks {
		b.Run(bm.name, func(count int) func(*testing.B) {
			return func(b *testing.B) {
				// setup
				var arr []uintptr
				newuintptr := new(uintptr)

				b.ReportAllocs()
				b.ResetTimer()

				for i := 0; i < b.N; i++ {
					for j := 0; j < count; j++ {
						arr = append(arr, *newuintptr)
					}
				}
			}
		}(bm.count))
	}
}
